<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>千里之行 始于足下 - 补码</title>
    <meta name="description" content="">
    <meta name="author" content="qianlizhixing">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Le styles -->
    <link href="/theme/bootstrap.min.css" rel="stylesheet">
    <link href="/theme/bootstrap.min.responsive.css" rel="stylesheet">
    <link href="/theme/local.css" rel="stylesheet">
    <link href="/theme/pygments.css" rel="stylesheet">
    <link rel="shortcut icon" href="/theme/images/icons/favicon.ico" type="image/x-icon">
</head>

<body>

    <div class="navbar">
        <div class="navbar-inner">
            <div class="container">

                <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </a>

                <a class="brand" name="hostpage">千里之行 始于足下</a>

                <div class="nav-collapse">
                    <ul class="nav">
                    </ul>
                </div>

            </div>
        </div>
    </div>

    <div class="container">
        <div class="content">
            <div class="row">

                <div class="span9">
        

        


    <div class='article'>
        <div class="content-title">
            <a href="/artsdi-jiu-zhou.html"><h1>ARTS第九周</h1></a>
2020-06-15

<a class="url fn">qianlizhixing</a>


 
        </div>
        
        <div><h2>Algorithm</h2>
<p>leetcode 231 2的幂</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/power-of-two/">原题</a></li>
<li><a href="https://github.com/qianlizhixing12/leetcode/blob/master/c/231.c">解题</a></li>
</ul>
<h2>Review</h2>
<blockquote>
<p>https://medium.com/cracking-the-data-science-interview/how-operating-systems-work-10-concepts-you-should-know-as-a-developer-8d63bb38331f</p>
</blockquote>
<p>关于操作系统，开发人员应该知道的10个概念。</p>
<ul>
<li>操作系统有三个关键元素</li>
<li>抽象(进程、线程、文件、套接字、内存)</li>
<li>机制(创建、调度、打开、写、分配)</li>
<li>策略(LRU、EDF)</li>
<li>操作系统设计有两个原则</li>
<li>通过实现灵活的机制来支持策略，实现机制和策略的分离</li>
<li>针对常见情况的优化:将OS用在哪里?用户希望在该机器上执行什么?工作负载要求是什么?</li>
<li>进程管理</li>
<li>一个程序被加载到内存中并成为一个进程时，它可以被分为四个部分:堆栈、堆、文本和数据<ul>
<li>栈:进程栈包含临时数据，如方法/函数参数、返回地址和局部变量。</li>
<li>堆:在进程运行时动态分配内存。</li>
<li>文本:这包括由程序计数器的值和处理器寄存器的内容所表示的当前活动。</li>
<li>数据:此部分包含全局变量和静态变量。</li>
</ul>
</li>
<li>当进程执行时，它会经过不同的状态<ul>
<li>启动:进程第一次启动/创建时的初始状态。</li>
<li>准备:进程正在等待分配给处理器。就绪进程正在等待操作系统为它们分配处理器，以便它们能够运行。进程可能在启动状态之后进入这种状态，或者在运行它时被调度程序中断，以便将CPU分配给其他进程。</li>
<li>运行:一旦进程被OS调度器分配给处理器，进程状态被设置为运行，处理器执行它的指令。</li>
<li>等待:如果进程需要等待一个资源，比如等待用户输入，或者等待一个文件可用，它就会进入等待状态。</li>
<li>终止或退出:一旦进程完成执行，或者被操作系统终止，它就会被移动到终止状态，等待从主存中删除。</li>
</ul>
</li>
<li>进程控制块是操作系统为每个进程维护的数据结构。PCB由一个整数进程ID (PID)标识，PCB可以保存跟踪过程所需的所有信息。<ul>
<li>进程状态:进程的当前状态——准备、运行、等待或其他状态。</li>
<li>进程特权:这是允许/不允许访问系统资源所必需的。</li>
<li>进程ID:操作系统中每个进程的唯一标识。</li>
<li>指针:指向父进程的指针。</li>
<li>程序计数器:程序计数器是指向此进程要执行的下一条指令地址的指针。</li>
<li>CPU寄存器:各种CPU寄存器，其中的进程需要被存储以执行运行状态。</li>
<li>CPU调度信息:进程优先级和进程调度所需的其他调度信息。</li>
<li>内存管理信息:这包括页表、内存限制和段表的信息，具体取决于操作系统使用的内存。</li>
<li>会计信息:这包括用于进程执行的CPU数量、时间限制、执行ID，等等。</li>
<li>IO状态信息:包括分配给进程的I/O设备列表。</li>
</ul>
</li>
<li>线程和并发</li>
<li>线程是通过进程代码执行的流。它有自己的程序计数器，用来跟踪下一步要执行的指令。它还有保存当前工作变量的系统寄存器，以及包含执行历史的堆栈。</li>
<li>线程与其对等线程共享各种信息，如代码段、数据段和打开的文件。当一个线程改变一个代码段内存项时，所有其他线程都会看到。</li>
<li>线程也称为轻量级进程。线程提供了一种通过并行提高应用程序性能的方法。线程代表了一种通过减少开销来提高操作系统性能的软件方法。线程相当于经典进程。</li>
<li>每个线程只属于一个进程，没有线程可以存在于进程之外。每个线程代表一个单独的控制流。线程已经成功地用于实现网络服务器和web服务器。它们还为在共享内存多处理器上并行执行应用程序提供了合适的基础。</li>
<li>线程优点<ul>
<li>它们将上下文切换时间最小化。</li>
<li>使用它们可以在进程中提供并发性。</li>
<li>他们提供有效的沟通。</li>
<li>创建和上下文切换线程更经济。</li>
<li>线程允许更大规模和更高效地利用多处理器架构。</li>
</ul>
</li>
<li>线程通过以下两种方式实现:<ul>
<li>用户级线程:用户管理线程。</li>
<li>内核级线程:作用于内核(操作系统核心)的操作系统托管线程。</li>
</ul>
</li>
<li>调度管理</li>
<li>调度进程是进程管理器的职责，它处理从CPU删除正在运行的进程和根据特定策略选择另一个进程。</li>
<li>操作系统在进程调度队列中维护所有的进程控制块。操作系统为每个进程状态维护一个单独的队列，处于相同执行状态的所有进程的pcb放在同一个队列中。当进程的状态发生改变时，它的PCB将与当前队列断开连接，并移动到新的状态队列。</li>
<li>操作系统维护以下重要的进程调度队列:<ul>
<li>作业队列:这个队列保存系统中的所有进程。</li>
<li>就绪队列:这个队列保存了一组驻留在主内存中的准备就绪并等待执行的所有进程。一个新进程总是放在这个队列中。</li>
<li>设备队列:由于I/O设备不可用而阻塞的进程组成这个队列。</li>
</ul>
</li>
<li>操作系统可以使用不同的策略来管理每个队列(FIFO、轮循、优先级等)。</li>
<li>上下文切换是在进程控制块中存储和恢复CPU状态或上下文的机制。它允许稍后从同一点恢复进程执行。使用这种技术，上下文切换器允许多个进程共享一个CPU。上下文切换是多任务操作系统的一个基本特性。</li>
<li>当调度器将CPU从执行一个进程切换到另一个进程时，当前运行进程的状态存储在进程控制块中。在此之后，下一个进程的状态将从它自己的PCB加载，并用于设置PC、寄存器等。此时，第二个流程可以开始执行。</li>
<li>内存管理</li>
<li>内存管理是操作系统处理或管理主内存的功能。它在执行期间在主内存和磁盘之间来回移动进程。</li>
<li>内存管理跟踪每个内存位置，不管它是分配给某个进程还是空闲。它检查要给进程分配多少内存。它决定哪个进程将在什么时候获得内存。它跟踪内存何时被释放或未分配，并相应地更新状态。</li>
<li>进程地址空间是进程在其代码中引用的一组逻辑地址。</li>
<li>在向程序分配内存时，操作系统负责将逻辑地址映射到物理地址。有三种类型的地址使用在一个程序之前和之后的内存分配:<ul>
<li>符号地址:在源代码中使用的地址。变量名、常量和指令标签是符号地址空间的基本元素。</li>
<li>相对地址:在编译时，编译器将符号地址转换成相对地址。</li>
<li>物理地址:当程序被加载到主存中时，加载程序会生成这些地址。</li>
</ul>
</li>
<li>在编译时和加载时地址绑定方案中，虚拟地址和物理地址是相同的。虚拟地址和物理地址在执行时地址绑定方案上是不同的。</li>
<li>由程序生成的所有逻辑地址的集合称为逻辑地址空间。与这些逻辑地址对应的所有物理地址的集合称为物理地址空间。</li>
<li>进程间通信</li>
<li>进程间通信(IPC)是一种机制，它允许进程之间进行通信并同步它们的动作。这些过程之间的通信可以看作是它们之间的一种合作方式。</li>
<li>进程之间可以通过两种方式进行通信:共享内存和消息解析。</li>
<li>共享内存的方法<ul>
<li>假设有两个过程:生产者和消费者。生产者生产某种产品，消费者消费该产品。这两个进程共享一个称为“缓冲区”的公共空间或内存位置，生产者生产的产品存储在这里，如果需要，消费者从这里消费产品。</li>
<li>这个问题有两个版本:第一个是无界缓冲区问题，生产者可以继续生产产品，缓冲区的大小没有限制。第二个问题称为有界缓冲区问题，生产者最多可以生产一定数量的产品，然后开始等待消费者消费这些产品。</li>
<li>在有界缓冲区问题中，生产者和消费者将共享一些公共内存。然后生产者将开始生产产品。如果生产的产品总数等于缓冲区的大小，生产者将等待，直到它们被消费者消费。</li>
<li>类似地，消费者首先检查产品的可用性，如果没有可用的产品，消费者将等待生产者生产它。如果有可用的商品，消费者就会消费它们。</li>
</ul>
</li>
<li>消息解析方法<ul>
<li>建立通信链路(如果链路已经存在，则无需再次建立)。</li>
<li>开始使用基本原语交换消息。我们至少需要两个原语:send(message, destination)或send(message)和receive(message, host)或receive(message)</li>
<li>消息大小可以是固定的，也可以是可变的。如果它的大小是固定的，那么对操作系统设计者来说很容易，但对程序员来说很复杂。如果它是可变大小的，那么它对程序员来说很容易，但对操作系统设计者来说很复杂。标准消息有两部分:头和正文。</li>
<li>消息头用于存储消息类型、目标id、源id、消息长度和控制信息。控制信息包含如下信息:如果缓冲区空间不够怎么办、序列号和优先级。通常，消息是使用FIFO样式发送的。</li>
</ul>
</li>
<li>I/O管理</li>
<li>一个I/O系统需要接收一个应用程序I/O请求并将其发送到物理设备，然后接收从设备返回的任何响应并将其发送到应用程序。I/O设备可分为两类:<ul>
<li>块设备:块设备是驱动程序通过发送整个数据块与之通信的设备。例如，硬盘、USB相机、带键磁盘等等。</li>
<li>字符设备:字符设备是驱动程序通过发送和接收单个字符(字节，八进制)进行通信的设备。例如，串口、并行口、声卡等等。</li>
</ul>
</li>
<li>中央处理器必须有一种方式来传递信息到和从一个I/O设备。有三种方法可用来与CPU和设备通信。<ul>
<li>特殊指令I / O，它使用专门为控制I/O设备而制作的CPU指令。这些指令通常允许将数据发送到I/O设备或从I/O设备读取数据。</li>
<li>内存映射I / O，内存和I/O设备共享相同的地址空间。该设备直接连接到某些主存储器位置，以便I/O设备可以传输数据块到/从存储器，而不经过中央处理器。在使用内存映射I/O时，OS在内存中分配缓冲区，并通知I/O设备使用该缓冲区向CPU发送数据。I/O设备与CPU异步操作，并在完成时中断CPU。这种方法的优点是，可以访问内存的每条指令都可以用来操作I/O设备。内存映射I/O用于大多数高速I/O设备，如磁盘和通信接口。</li>
<li>直接存储器存取(DMA)，慢速设备如键盘将产生一个中断到主CPU后，每个字节被转移。如果一个快速设备(如磁盘)为每个字节产生中断，操作系统将花费大部分时间来处理这些中断。因此，典型的计算机使用直接内存访问(DMA)硬件来减少这一开销。直接内存访问(DMA)意味着CPU授予I/O模块权力，从内存读取或写入，而不参与。DMA模块本身控制主存储器和I/O设备之间的数据交换。CPU只参与传输的开始和结束，只有在整个块被传输之后才会中断。直接内存访问需要称为DMA控制器(DMAC)的特殊硬件来管理数据传输和仲裁访问系统总线。控制器编程与源和目标指针(在那里读/写数据)，计数器跟踪传输字节的数量，和各种设置。这包括I/O和内存类型以及CPU周期的中断和状态。</li>
</ul>
</li>
<li>虚拟化</li>
<li>允许从单个物理硬件系统创建多个模拟环境或专用资源的技术。</li>
<li>分布式文件系统</li>
<li>分布式共享内存</li>
<li>云计算</li>
</ul>
<h2>Tip</h2>
<h3>位运算</h3>
<blockquote>
<p>https://graphics.stanford.edu/~seander/bithacks.html</p>
</blockquote>
<ul>
<li>左移&lt;&lt;</li>
<li>右移&gt;&gt;</li>
<li>按位或|</li>
<li>按位与&amp;</li>
<li>按位取反~</li>
<li>按位异或^</li>
</ul>
<h4>特殊性质</h4>
<ul>
<li>x ^ 0 = x</li>
<li>x ^ (~0) = ~x</li>
<li>x ^ (~x) = ~0</li>
<li>x ^ x = 0</li>
<li>c = a ^ b =&gt; a ^ c = b, b ^ c = a // 交换两个数</li>
<li>a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c</li>
</ul>
<h4>指定位置位运算</h4>
<ul>
<li>将 x 最右边的 n 位清零：x &amp; (~0 &lt;&lt; n)</li>
<li>获取 x 的第 n 位值（0 或者 1）： (x &gt;&gt; n) &amp; 1</li>
<li>获取 x 的第 n 位的幂值：x &amp; (1 &lt;&lt; (n -1))</li>
<li>仅将第 n 位置为 1：x | (1 &lt;&lt; n)</li>
<li>仅将第 n 位置为 0：x &amp; (~ (1 &lt;&lt; n))</li>
<li>将 x 最高位至第 n 位（含）清零：x &amp; ((1 &lt;&lt; n) - 1)</li>
<li>将第 n 位至第 0 位（含）清零：x &amp; (~ ((1 &lt;&lt; (n + 1)) - 1))</li>
</ul>
<h4>实战位运算要点</h4>
<ul>
<li>判断奇偶</li>
<li>x % 2 == 1 —&gt; (x &amp; 1) == 1</li>
<li>x % 2 == 0 —&gt; (x &amp; 1) == 0</li>
<li>x &gt;&gt; 1 —&gt; x / 2</li>
<li>x = x / 2 —&gt; x = x &gt;&gt; 1</li>
<li>mid = (left + right) / 2 —&gt; mid = (left + right) &gt;&gt; 1</li>
<li>X = X &amp; (X-1) 清零最低位的 1</li>
<li>计算汉明权重(二进制1的个数)</li>
<li>判断是否 2 的指数</li>
<li>X &amp; -X =&gt; 得到最低位的 1 </li>
<li>X &amp; ~X =&gt; 0</li>
<li>转换大小写</li>
<li>'z' | ' '  == 'z'</li>
<li>'Z | ' '  == 'z'</li>
<li>'z' &amp; '_' == 'Z'</li>
<li>'Z' &amp; '_' == 'Z'</li>
<li>'z' ^ ' ' = 'Z'</li>
<li>'Z' ^ ' ' = 'z'</li>
<li>两个数是否异号</li>
<li>(x ^ y) &lt; 0</li>
<li>加一</li>
<li>-~n</li>
<li>减一</li>
<li>~-n</li>
</ul>
<h2>Share</h2>
<h3>计算机数值表示</h3>
<blockquote>
<p>https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81</p>
<p>https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</p>
</blockquote>
<ul>
<li>计算机的基本储存单位是bit(位)，通过物理信号(开关变化设置等)表达值0或1。</li>
<li>计算机使用不同数量的bit储存不同种类的信息，8个bit成为byte(字节)。</li>
<li>八进制和十六进制使得转换二进制机器级的数字变得简单方便。</li>
</ul>
<h4>无符号整数</h4>
<ul>
<li>只能在所有的位的范围内进行算术操作。否则将得到一个“数据溢出”的错误。这个术语表明，正在进行的是“有限精度”的操作。</li>
<li>这种编码不能表示小数，只能使用非小数的“整数”。</li>
<li>这种编码不能表示负数，所有的数字都是“无符号数”。</li>
</ul>
<h4>有符号整数</h4>
<ul>
<li>最简单的一个方法是保留一个位来表示数值的符号。这个“符号位”可以位于数值的最左边，当然也可以位于数值的最右边。如果这个符号位为0，表示数值是正的，如果这个符号位为1，表示数值是负的。</li>
<li>人类的角度来看是最明显的解决方案，但是它对于计算机来说有可能带来一些难度。这种编码使得0可以有正负两种。</li>
<li>对计算机来说，更自然的表达方式是对给定的位数的二进制数按其范围分成两半，其中前一半用来表示负数。</li>
</ul>
<h4>加法器实现+</h4>
<p>不考虑进位的情况下(半加器)，通过基本逻辑单路异或电路就能实现和的计算。</p>
<p>在半加器基础上改进，使得输入有进位，输出有进位，即三输入二输出的一个部件，全加速。</p>
<p>(不考虑具体物理电路，敬佩牛逼，讨论下为啥这样实现)</p>
<h4>原码</h4>
<ul>
<li>原码是符号位加上真值的绝对值, 用第一位表示符号, 其余位表示值。</li>
<li>原码是人脑最容易理解和计算的表示方式。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">[+2]原 = 0000 0010</span>
<span class="err">[-2]原 = 1000 0010</span>
<span class="err">[+1]原 = 0000 0001</span>
<span class="err">[-1]原 = 1000 0001</span>
</code></pre></div>


<ul>
<li>用原码计算</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">[+2]原 + [+1]原 = 0000 0010 + 0000 0001 = 0000 0011 = [+3]原  //正加正上面的加法器ok</span>
<span class="err">[+2]原 + [-1]原 = 0000 0010 + 1000 0001 = 1000 0011 = [-3]原  //正加负上面的加法器不ok，要改进，要考虑借位(借位还要根据数值)，照这个思路设计好了，其实是把加负数改为减负数了，还要考虑符号，想想都麻烦</span>
</code></pre></div>


<ul>
<li>总结用原码实现加减法，电路设计复杂，想想就复杂，咱也不是电路人。</li>
</ul>
<h4>反码</h4>
<ul>
<li>正数的反码是其本身。</li>
<li>负数的反码是符号位不变，其余各个位取反。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">[+2]反 = 0000 0010</span>
<span class="err">[-2]反 = 1111 1101</span>
<span class="err">[+1]反 = 0000 0001</span>
<span class="err">[-1]反 = 1111 1110</span>
</code></pre></div>


<ul>
<li>用反码计算</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">[+2]反 + [+1]反 = 0000 0010 + 0000 0001 = 0000 0011反 = [+3]原  //正加正上面的加法器ok</span>
<span class="err">[+2]反 + [-1]反 = 0000 0010 + 1111 1110 = 0000 0000反 = [0]原  //正加负上面的加法器不ok</span>
<span class="err">[-2]反 + [+1]反 = 1111 1101 + 0000 0001 = 1111 1110反 = 1000 0001原 = [-1]原  //正加负上面的加法器ok</span>
<span class="err">[-2]反 + [-1]反 = 1111 1101 + 1111 1110 = 0000 0011反 = 0000 0011原 = [+3]原  //负加负上面的加法器不ok</span>
<span class="err">[+2]反 + [-2]反 = 0000 0010 + 1111 1110 = 0000 0000反 = [+0]原  //正加负上面的加法器ok</span>
</code></pre></div>


<h4>补码</h4>
<ul>
<li>正数的补码是其本身</li>
<li>负数的补码是符号位不变, 其余各位取反, 最后+1。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">[+2]补 = 0000 0010</span>
<span class="err">[-2]补 = 1111 1110</span>
<span class="err">[+1]补 = 0000 0001</span>
<span class="err">[-1]补 = 1111 1111</span>
</code></pre></div>


<ul>
<li>用补码计算</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">[+2]补 + [+1]补 = 0000 0010 + 0000 0001 = 0000 0011补 = [+3]原  //正加正上面的加法器ok</span>
<span class="err">[+2]补 + [-1]补 = 0000 0010 + 1111 1111 = 0000 0001补 = [0]原  //正加负上面的加法器ok</span>
<span class="err">[-2]补 + [+1]补 = 1111 1110 + 0000 0001 = 1111 1111补 = 1000 0001原 = [-1]原  //负加正上面的加法器ok</span>
<span class="err">[-2]补 + [-1]补 = 1111 1110 + 1111 1111 = 1111 1101补 = 1000 0011原 = [-3]原  //负加负上面的加法器ok</span>
<span class="err">[+2]补 + [-2]补 = 0000 0010 + 1111 1110 = 0000 0000补 = [0]原  //正加负上面的加法器ok</span>
</code></pre></div>


<h4>总结</h4>
<ul>
<li>计算机系统中，数值一律用补码来表示和存储。使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理，简化了计算机加减法的电路设计。</li>
<li>上面的原码，反码，补码，怎么比较“凑巧”的得到上一条总结的，我自己都是蒙的哈哈。这个是从电路和工程师角度，一般人脑逻辑感受并不直观，甚至别扭，再次致敬。</li>
</ul>
<h4>补码背后数学逻辑</h4>
<p>将钟表想象成是一个1位的12进制数。 如果当前时间是6点,，我希望将时间设置成4点，需要怎么做呢？我们可以：</p>
<ul>
<li>往回拨2个小时: 6 - 2 = 4</li>
<li>往前拨10个小时: (6 + 10) mod 12 = 4</li>
<li>往前拨10+12=22个小时: (6+22) mod 12 =4</li>
</ul>
<p>钟表往回拨(减法)的结果可以用往前拨(加法)替代，现在的焦点就落在了如何用一个正数，来替代一个负数。</p>
<h5>同余</h5>
<p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余，记作 a ≡ b (mod m)，读作 a 与 b 关于模 m 同余。</p>
<h5>取模</h5>
<p>数学定义</p>
<p><img alt="取模定义" src=".\img\取模定义.jpg"></p>
<p>x mod y等于 x 减去 y 乘上 x与y的商的下界。</p>
<ul>
<li>(-2) mod 12 = 12-2=10</li>
<li>(-4) mod 12 = 12-4 = 8</li>
<li>(-5) mod 12 = 12 - 5 = 7</li>
</ul>
<p>退回几步(-2)等于前进几步(10)，跑圈，跑12步回到原点。</p>
<h5>线性运算定理</h5>
<p>如果a ≡ b (mod m)，c ≡ d (mod m) 那么:</p>
<p>(1)a ± c ≡ b ± d (mod m)</p>
<p>(2)a * c ≡ b * d (mod m)</p>
<p>6 ≡ 6 (mod 12)</p>
<p>(-2) ≡ 10 (mod 12)</p>
<p>6 -2 ≡ 6 + 10 (mod 12)</p>
<h5>二进制补码取模对比</h5>
<p>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反</p>
<p>-1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126</p>
<p>(-1) mod 127 = 126</p>
<p>126 mod 127 = 126</p>
<p>(-1) ≡ 126 (mod 127)</p>
<p>2-1 ≡ 2+126 (mod 127)</p>
<p>2+126很显然相当于钟表转过了一轮, 而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果。</p>
<p>在反码的基础上+1, 只是相当于增加了膜的值。</p></div>
        <hr />
    </div>
		
<div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&larr; Previous</a></li>

    <li class="active"><a href="/tag/bu-ma.html">1</a></li>

    <li class="next disabled"><a href="#">&rarr; Next</a></li>

</ul>
</div>
 
  
                </div>

                <div class="span3">

                    <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
                        <ul class="nav nav-list">
                            <li class="nav-header">
                                Site
                            </li>

                            <li><a href="/archives.html">Archives</a>
                            <li><a href="/tags.html">Tags</a>
                        </ul>
                    </div>


                    <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
                        <ul class="nav nav-list">
                            <li class="nav-header">
                                Categories
                            </li>

                            <li><a href="/category/arts.html">ARTS</a></li>
                        </ul>
                    </div>
                </div>             </div>         </div> 
        <footer>
            <br />
            <p><a name="hostpage">千里之行 始于足下</a> &copy; qianlizhixing 2020</p>
        </footer>

    </div> <!-- /container -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="/theme/bootstrap-collapse.js"></script>
    <script>
        document.getElementsByName("hostpage").forEach((item) => {
            item.href = window.location.origin;
        });
    </script>
</body>

</html>